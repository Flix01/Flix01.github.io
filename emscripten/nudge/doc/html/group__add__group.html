<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nudge Physics: Add-Bodies Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Nudge Physics
   </div>
   <div id="projectbrief">A single file, header-only 3D physics library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__add__group.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Add-Bodies Functions</div></div>
</div><!--header-->
<div class="contents">

<p>Set of functions regarding creation and removal of physic bodies.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadfab72b0d7cd266e437b457d9b088748" id="r_gadfab72b0d7cd266e437b457d9b088748"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#gadfab72b0d7cd266e437b457d9b088748">nudge::add_box</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float hsizex, float hsizey, float hsizez, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *T=NULL, const float comOffset[3]=NULL)</td></tr>
<tr class="memdesc:gadfab72b0d7cd266e437b457d9b088748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new body to the simulation with a single box collider.  <br /></td></tr>
<tr class="separator:gadfab72b0d7cd266e437b457d9b088748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5727479f38a422ed7a8d758fe2fd48de" id="r_ga5727479f38a422ed7a8d758fe2fd48de"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga5727479f38a422ed7a8d758fe2fd48de">nudge::add_box</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float hsizex, float hsizey, float hsizez, const float *mMatrix16WithoutScaling, const float comOffset[3]=NULL)</td></tr>
<tr class="separator:ga5727479f38a422ed7a8d758fe2fd48de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94b8c65bfc0102f2306d8fa96ee0dbc4" id="r_ga94b8c65bfc0102f2306d8fa96ee0dbc4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga94b8c65bfc0102f2306d8fa96ee0dbc4">nudge::add_sphere</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float radius, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *T=NULL, const float comOffset[3]=NULL)</td></tr>
<tr class="memdesc:ga94b8c65bfc0102f2306d8fa96ee0dbc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new body to the simulation with a single sphere collider.  <br /></td></tr>
<tr class="separator:ga94b8c65bfc0102f2306d8fa96ee0dbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f0a78d26be31086f2b6139eea50e76" id="r_ga97f0a78d26be31086f2b6139eea50e76"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga97f0a78d26be31086f2b6139eea50e76">nudge::add_sphere</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float radius, const float *mMatrix16WithoutScaling, const float comOffset[3]=NULL)</td></tr>
<tr class="separator:ga97f0a78d26be31086f2b6139eea50e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb36d216cbf7665a6bef0564ecf3194e" id="r_gabb36d216cbf7665a6bef0564ecf3194e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#gabb36d216cbf7665a6bef0564ecf3194e">nudge::add_compound</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float inertia[3], unsigned num_boxes, const float *hsizeTriplets, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *boxOffsetTransforms, unsigned num_spheres, const float *radii, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *sphereOffsetTransforms, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *T=NULL, const float comOffset[3]=NULL, float *centerMeshAndRetrieveOldCenter3Out=NULL)</td></tr>
<tr class="memdesc:gabb36d216cbf7665a6bef0564ecf3194e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new body to the simulation with a compound collider made up of num_boxes box colliders and num_spheres sphere colliders.  <br /></td></tr>
<tr class="separator:gabb36d216cbf7665a6bef0564ecf3194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c939bba303decff11acc3af224ab6f" id="r_gac3c939bba303decff11acc3af224ab6f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#gac3c939bba303decff11acc3af224ab6f">nudge::add_compound</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, float mass, float inertia[3], unsigned num_boxes, const float *hsizeTriplets, const float *boxOffsetMatrices16WithoutScaling, unsigned num_spheres, const float *radii, const float *sphereOffsetMatrices16WithoutScaling, const float *mMatrix16WithoutScaling=NULL, const float comOffset[3]=NULL, float *centerMeshAndRetrieveOldCenter3Out=NULL)</td></tr>
<tr class="separator:gac3c939bba303decff11acc3af224ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996425d8924b4bababdc993e30e6dce0" id="r_ga996425d8924b4bababdc993e30e6dce0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga996425d8924b4bababdc993e30e6dce0">nudge::add_clone</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, unsigned body_to_clone, float mass, const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *T=NULL, float scale_factor=1.f, const float newComOffsetInPreScaledUnits[3]=NULL)</td></tr>
<tr class="memdesc:ga996425d8924b4bababdc993e30e6dce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Experimental] Adds a new body to the simulation cloning an existing body  <br /></td></tr>
<tr class="separator:ga996425d8924b4bababdc993e30e6dce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc5e530e44071014a4c572f89c3b481" id="r_ga6fc5e530e44071014a4c572f89c3b481"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga6fc5e530e44071014a4c572f89c3b481">nudge::add_clone</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, unsigned body_to_clone, float mass, const float *mMatrix16WithoutScaling, float scale_factor=1.f, const float newComOffsetInPreScaledUnits[3]=NULL)</td></tr>
<tr class="separator:ga6fc5e530e44071014a4c572f89c3b481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37580dde6372ae0379b030efde812d32" id="r_ga37580dde6372ae0379b030efde812d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga37580dde6372ae0379b030efde812d32">nudge::remove_body</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, unsigned body)</td></tr>
<tr class="memdesc:ga37580dde6372ae0379b030efde812d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a body from the simulation.  <br /></td></tr>
<tr class="separator:ga37580dde6372ae0379b030efde812d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7eae5e6e78aca5e58d68f57c0b27b6" id="r_ga7a7eae5e6e78aca5e58d68f57c0b27b6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga7a7eae5e6e78aca5e58d68f57c0b27b6">nudge::colliders_get_num_remaining_boxes</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c)</td></tr>
<tr class="memdesc:ga7a7eae5e6e78aca5e58d68f57c0b27b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of box colliders that can still be added to the physic world.  <br /></td></tr>
<tr class="separator:ga7a7eae5e6e78aca5e58d68f57c0b27b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9" id="r_ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9">nudge::colliders_get_num_remaining_spheres</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c)</td></tr>
<tr class="memdesc:ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of sphere colliders that can still be added to the physic world.  <br /></td></tr>
<tr class="separator:ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bd7e16bb70f5d62af617ea052c925f" id="r_ga13bd7e16bb70f5d62af617ea052c925f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga13bd7e16bb70f5d62af617ea052c925f">nudge::can_add_box</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c)</td></tr>
<tr class="separator:ga13bd7e16bb70f5d62af617ea052c925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5daf3798a9cd8895329eb3fae98c9f" id="r_gaeb5daf3798a9cd8895329eb3fae98c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#gaeb5daf3798a9cd8895329eb3fae98c9f">nudge::can_add_sphere</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c)</td></tr>
<tr class="separator:gaeb5daf3798a9cd8895329eb3fae98c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd9f9353cbaa67f9ba9e809cd59047e" id="r_ga2dd9f9353cbaa67f9ba9e809cd59047e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga2dd9f9353cbaa67f9ba9e809cd59047e">nudge::can_add_compound</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, unsigned num_boxes, unsigned num_spheres)</td></tr>
<tr class="separator:ga2dd9f9353cbaa67f9ba9e809cd59047e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343f3f618f0fe483a2737714e4d59863" id="r_ga343f3f618f0fe483a2737714e4d59863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga343f3f618f0fe483a2737714e4d59863">nudge::can_add_clone</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, unsigned body_to_clone)</td></tr>
<tr class="separator:ga343f3f618f0fe483a2737714e4d59863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f53241ed3f4a4ee707c312731580076" id="r_ga4f53241ed3f4a4ee707c312731580076"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga4f53241ed3f4a4ee707c312731580076">nudge::get_next_add_body_index</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c)</td></tr>
<tr class="memdesc:ga4f53241ed3f4a4ee707c312731580076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to peek the body index that is going to be returned in next <a class="el" href="group__add__group.html">add_xxx(...)</a> call.  <br /></td></tr>
<tr class="separator:ga4f53241ed3f4a4ee707c312731580076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f93cae567db28c0208a5494260b6cff" id="r_ga1f93cae567db28c0208a5494260b6cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga1f93cae567db28c0208a5494260b6cff">nudge::body_recalculate_bounding_box</a> (<a class="el" href="structnudge_1_1context__t.html">context_t</a> *c, uint32_t body)</td></tr>
<tr class="memdesc:ga1f93cae567db28c0208a5494260b6cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculates the bounding box of the body (<a class="el" href="structnudge_1_1BodyInfo.html">BodyInfo::aabb_center and BodyInfo::aabb_extents</a>)  <br /></td></tr>
<tr class="separator:ga1f93cae567db28c0208a5494260b6cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7780301e58b1427a98bf9528b364286" id="r_gac7780301e58b1427a98bf9528b364286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#gac7780301e58b1427a98bf9528b364286">nudge::body_change_motion_state</a> (<a class="el" href="structnudge_1_1context__t.html">nudge::context_t</a> *c, unsigned body, <a class="el" href="namespacenudge.html#a18b09ad52308ede8a1c65cc0ba442adf">nudge::FlagMask</a> new_motion_state, float mass_fallback=1.f)</td></tr>
<tr class="memdesc:gac7780301e58b1427a98bf9528b364286"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Experimental] Changes the body motion state (i.e. the BF_IS_STATIC_OR_KINEMATIC_OR_DYNAMIC group of body flags)  <br /></td></tr>
<tr class="separator:gac7780301e58b1427a98bf9528b364286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f40bbfb338b401de8427b86287981f" id="r_ga94f40bbfb338b401de8427b86287981f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add__group.html#ga94f40bbfb338b401de8427b86287981f">nudge::body_scale</a> (<a class="el" href="structnudge_1_1context__t.html">nudge::context_t</a> *c, unsigned body, float scale_factor, float mass_scale_factor=0.f)</td></tr>
<tr class="memdesc:ga94f40bbfb338b401de8427b86287981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Experimental] Uniformly scales the specified body incrementally  <br /></td></tr>
<tr class="separator:ga94f40bbfb338b401de8427b86287981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Set of functions regarding creation and removal of physic bodies. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadfab72b0d7cd266e437b457d9b088748" name="gadfab72b0d7cd266e437b457d9b088748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfab72b0d7cd266e437b457d9b088748">&#9670;&#160;</a></span>add_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizez</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>T</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new body to the simulation with a single box collider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">mass</td><td>positive =&gt; dynamic; 0 =&gt; static; negative =&gt; kinematic (where the absolute value will be used as mass internally) </td></tr>
    <tr><td class="paramname">hsizex</td><td>half box size in the x direction </td></tr>
    <tr><td class="paramname">hsizey</td><td>half box size in the y direction </td></tr>
    <tr><td class="paramname">hsizez</td><td>half box size in the z direction </td></tr>
    <tr><td class="paramname">T</td><td>a pointer to a <a class="el" href="structnudge_1_1Transform.html" title="The Transform struct.">Transform</a> </td></tr>
    <tr><td class="paramname">comOffset</td><td>an optional array of 3 floats that determines the center of mass offset of the body </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the body index, or <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> if no more boxes can be added </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally <a class="el" href="structnudge_1_1BodyProperties.html">mass_inverse and inertia_inverse</a> are always stored as positive values (except for static bodies): this makes kinematic to dynamic body conversions a bit easier </dd>
<dd>
Every time an <a class="el" href="group__add__group.html">add_xxx(...)</a> function is called, if c-&gt;global_data.finalized_removed_bodies_count&gt;0, the body c-&gt;global_data.removed_bodies[0] is always reused and returned </dd></dl>

</div>
</div>
<a id="ga5727479f38a422ed7a8d758fe2fd48de" name="ga5727479f38a422ed7a8d758fe2fd48de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5727479f38a422ed7a8d758fe2fd48de">&#9670;&#160;</a></span>add_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>hsizez</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mMatrix16WithoutScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mMatrix16WithoutScaling</td><td>a pointer to a 4x4 column-major matrix with only translation and rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94b8c65bfc0102f2306d8fa96ee0dbc4" name="ga94b8c65bfc0102f2306d8fa96ee0dbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94b8c65bfc0102f2306d8fa96ee0dbc4">&#9670;&#160;</a></span>add_sphere() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>T</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new body to the simulation with a single sphere collider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">mass</td><td>positive =&gt; dynamic; 0 =&gt; static; negative =&gt; kinematic (where the absolute value will be used as mass internally) </td></tr>
    <tr><td class="paramname">radius</td><td>the sphere radius </td></tr>
    <tr><td class="paramname">T</td><td>a pointer to a <a class="el" href="structnudge_1_1Transform.html" title="The Transform struct.">Transform</a> </td></tr>
    <tr><td class="paramname">comOffset</td><td>an optional array of 3 floats that determines the center of mass offset of the body </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the body index, or <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> if no more spheres can be added </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally <a class="el" href="structnudge_1_1BodyProperties.html">mass_inverse and inertia_inverse</a> are always stored as positive values (except for static bodies): this makes kinematic to dynamic body conversions a bit easier </dd>
<dd>
Every time an <a class="el" href="group__add__group.html">add_xxx(...)</a> function is called, if c-&gt;global_data.finalized_removed_bodies_count&gt;0, the body c-&gt;global_data.removed_bodies[0] is always reused and returned </dd></dl>

</div>
</div>
<a id="ga97f0a78d26be31086f2b6139eea50e76" name="ga97f0a78d26be31086f2b6139eea50e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97f0a78d26be31086f2b6139eea50e76">&#9670;&#160;</a></span>add_sphere() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mMatrix16WithoutScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mMatrix16WithoutScaling</td><td>a pointer to a 4x4 column-major matrix with only translation and rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb36d216cbf7665a6bef0564ecf3194e" name="gabb36d216cbf7665a6bef0564ecf3194e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb36d216cbf7665a6bef0564ecf3194e">&#9670;&#160;</a></span>add_compound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inertia</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>hsizeTriplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>boxOffsetTransforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_spheres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>sphereOffsetTransforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>T</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>centerMeshAndRetrieveOldCenter3Out</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new body to the simulation with a compound collider made up of num_boxes box colliders and num_spheres sphere colliders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">mass</td><td>positive =&gt; dynamic; 0 =&gt; static; negative =&gt; kinematic (where the absolute value will be used as mass internally) </td></tr>
    <tr><td class="paramname">inertia</td><td>an inertia tensor in a 3-float array form that is used only if mass is not zero (see also the <a class="el" href="group__inertia__group.html">inertia helper functions</a>); it can be NULL (in that case a box inertia on the body axis-aligned bounding box extents is used) </td></tr>
    <tr><td class="paramname">num_boxes</td><td></td></tr>
    <tr><td class="paramname">hsizeTriplets</td><td>pointer to an array of size 3*num_boxes floats </td></tr>
    <tr><td class="paramname">boxOffsetTransforms</td><td>pointer to an array of num_boxes Transforms </td></tr>
    <tr><td class="paramname">num_spheres</td><td></td></tr>
    <tr><td class="paramname">radii</td><td>pointer to an array of num_sphere floats </td></tr>
    <tr><td class="paramname">sphereOffsetTransforms</td><td>pointer to an array of num_sphere Transforms </td></tr>
    <tr><td class="paramname">T</td><td>a pointer to a <a class="el" href="structnudge_1_1Transform.html" title="The Transform struct.">Transform</a> </td></tr>
    <tr><td class="paramname">comOffset</td><td>an optional input array of 3 floats that determines the center of mass offset of the body </td></tr>
    <tr><td class="paramname">centerMeshAndRetrieveOldCenter3Out</td><td>[experimental] an optional output array of 3 floats: if set, the input mesh is recentered (before applying the comOffset) and the axis-aligned bounding box center that has been subtracted from the mesh is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the body index, or <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> if no more boxes can be added </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally <a class="el" href="structnudge_1_1BodyProperties.html">mass_inverse and inertia_inverse</a> are always stored as positive values (except for static bodies): this makes kinematic to dynamic body conversions a bit easier </dd>
<dd>
Every time an <a class="el" href="group__add__group.html">add_xxx(...)</a> function is called, if c-&gt;global_data.finalized_removed_bodies_count&gt;0, the body c-&gt;global_data.removed_bodies[0] is always reused and returned </dd></dl>

</div>
</div>
<a id="gac3c939bba303decff11acc3af224ab6f" name="gac3c939bba303decff11acc3af224ab6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3c939bba303decff11acc3af224ab6f">&#9670;&#160;</a></span>add_compound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inertia</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>hsizeTriplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>boxOffsetMatrices16WithoutScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_spheres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>sphereOffsetMatrices16WithoutScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mMatrix16WithoutScaling</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>comOffset</em>[3] = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>centerMeshAndRetrieveOldCenter3Out</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mMatrix16WithoutScaling</td><td>a pointer to a 4x4 column-major matrix with only translation and rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga996425d8924b4bababdc993e30e6dce0" name="ga996425d8924b4bababdc993e30e6dce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996425d8924b4bababdc993e30e6dce0">&#9670;&#160;</a></span>add_clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body_to_clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnudge_1_1Transform.html">Transform</a> *&#160;</td>
          <td class="paramname"><em>T</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>newComOffsetInPreScaledUnits</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Experimental] Adds a new body to the simulation cloning an existing body </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">body_to_clone</td><td>the body to clone </td></tr>
    <tr><td class="paramname">mass</td><td>positive =&gt; dynamic; 0 =&gt; static; negative =&gt; kinematic (where the absolute value will be used as mass internally) </td></tr>
    <tr><td class="paramname">T</td><td>a pointer to a <a class="el" href="structnudge_1_1Transform.html" title="The Transform struct.">Transform</a> </td></tr>
    <tr><td class="paramname">scale_factor</td><td>positive =&gt; the uniform scaling factor to apply (to each single axis); negative =&gt; scale so that the half bounding box y-component of the body becomes exactly -scaling_factor; 0 =&gt; invalid value (asserts) </td></tr>
    <tr><td class="paramname">newComOffsetInPreScaledUnits</td><td>if set, an absolute new center of mass offset will be added (replacing the old one if present) using the pre-scaled coordinates; otherwise the old center of mass offset (if present) is kept (and possibly scaled) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the body index, or <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> if no more boxes can be added </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Internally <a class="el" href="structnudge_1_1BodyProperties.html">mass_inverse and inertia_inverse</a> are always stored as positive values (except for static bodies): this makes kinematic to dynamic body conversions a bit easier </dd>
<dd>
Every time an <a class="el" href="group__add__group.html">add_xxx(...)</a> function is called, if c-&gt;global_data.finalized_removed_bodies_count&gt;0, the body c-&gt;global_data.removed_bodies[0] is always reused and returned </dd></dl>

</div>
</div>
<a id="ga6fc5e530e44071014a4c572f89c3b481" name="ga6fc5e530e44071014a4c572f89c3b481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc5e530e44071014a4c572f89c3b481">&#9670;&#160;</a></span>add_clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::add_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body_to_clone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mMatrix16WithoutScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>newComOffsetInPreScaledUnits</em>[3] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mMatrix16WithoutScaling</td><td>a pointer to a 4x4 column-major matrix with only translation and rotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37580dde6372ae0379b030efde812d32" name="ga37580dde6372ae0379b030efde812d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37580dde6372ae0379b030efde812d32">&#9670;&#160;</a></span>remove_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nudge::remove_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a body from the simulation. </p>
<dl class="section note"><dt>Note</dt><dd>The body is actually removed next time <a class="el" href="group__main__group.html#ga5e40e2507c7ad9e6e547c843042c75f1">simulation_step(...)</a> is called (the call 'finalizes' the removal of all pending bodies). The body can't be reused after this call and could still be present in <a class="el" href="structnudge_1_1ContactData.html" title="The ContactData class.">ContactData</a> for some (1?) frames. In any case user can detect it with: ((*body_get_flags(...))&amp;BF_IS_REMOVED). Also removed bodies are NOT subtracted from c-&gt;bodies.count, but are reused when new bodies are added with: <a class="el" href="group__add__group.html">add_xxx(...)</a>. </dd>
<dd>
Internally, removed bodies are kept in the c-&gt;global_data.removed_bodies array. </dd>
<dd>
If you just want to reuse the body WITH THE SAME (optionally rescaled) collider(s) soon, you should not remove the body, but just change its properties (more efficient + no delay). </dd>
<dd>
Sometimes it's better to just disable a body, instead of removing it, using: (*body_get_flags(...))|=BF_IS_DISABLED: this way the body can be optionally put into a user-side custom list for later reusage/reactivation. This way the body colliders are preserved. </dd>
<dd>
Every time an <a class="el" href="group__add__group.html">add_xxx(...)</a> function is called, if c-&gt;global_data.finalized_removed_bodies_count&gt;0, the body: c-&gt;global_data.removed_bodies[0] is always returned. </dd>
<dd>
User data in the <a class="el" href="structnudge_1_1BodyInfo.html">BodyInfo</a> struct are NOT reset when a body is removed, but most of the other data are reset when removed bodies are finalized at the beginning of next <a class="el" href="group__main__group.html#ga5e40e2507c7ad9e6e547c843042c75f1">simulation_step(...)</a> call. </dd>
<dd>
That means that when bodies are reused in <a class="el" href="group__add__group.html">add_xxx(...)</a> functions, their old user data are preserved. </dd>
<dd>
Kinematic animations referencing removed bodies are assigned to <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> when removed bodies are finalized (there's an optional definition NUDGE_DELETE_KINEMATIC_ANIMATIONS_REFERENCING_REMOVED_BODIES to delete the kinematic animations instead). </dd></dl>

</div>
</div>
<a id="ga7a7eae5e6e78aca5e58d68f57c0b27b6" name="ga7a7eae5e6e78aca5e58d68f57c0b27b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7eae5e6e78aca5e58d68f57c0b27b6">&#9670;&#160;</a></span>colliders_get_num_remaining_boxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nudge::colliders_get_num_remaining_boxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of box colliders that can still be added to the physic world. </p>
<dl class="section note"><dt>Note</dt><dd>The maximum number can be set in <a class="el" href="group__context__group.html#gace870c8970819b6f81d1f48f3f8f8dfe">init_context_with(...)</a> and can't be changed at runtime </dd></dl>

</div>
</div>
<a id="ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9" name="ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9">&#9670;&#160;</a></span>colliders_get_num_remaining_spheres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nudge::colliders_get_num_remaining_spheres </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of sphere colliders that can still be added to the physic world. </p>
<dl class="section note"><dt>Note</dt><dd>The maximum number can be set in <a class="el" href="group__context__group.html#gace870c8970819b6f81d1f48f3f8f8dfe">init_context_with(...)</a> and can't be changed at runtime </dd></dl>

</div>
</div>
<a id="ga13bd7e16bb70f5d62af617ea052c925f" name="ga13bd7e16bb70f5d62af617ea052c925f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13bd7e16bb70f5d62af617ea052c925f">&#9670;&#160;</a></span>can_add_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nudge::can_add_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 if <a class="el" href="group__add__group.html#gadfab72b0d7cd266e437b457d9b088748">add_box(...)</a> can be called successfully </dd></dl>

</div>
</div>
<a id="gaeb5daf3798a9cd8895329eb3fae98c9f" name="gaeb5daf3798a9cd8895329eb3fae98c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5daf3798a9cd8895329eb3fae98c9f">&#9670;&#160;</a></span>can_add_sphere()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nudge::can_add_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 if <a class="el" href="group__add__group.html#ga94b8c65bfc0102f2306d8fa96ee0dbc4">add_sphere(...)</a> can be called successfully </dd></dl>

</div>
</div>
<a id="ga2dd9f9353cbaa67f9ba9e809cd59047e" name="ga2dd9f9353cbaa67f9ba9e809cd59047e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd9f9353cbaa67f9ba9e809cd59047e">&#9670;&#160;</a></span>can_add_compound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nudge::can_add_compound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_spheres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 if <a class="el" href="group__add__group.html#gabb36d216cbf7665a6bef0564ecf3194e">add_compound(...)</a> can be called successfully with num_boxes and num_spheres </dd></dl>

</div>
</div>
<a id="ga343f3f618f0fe483a2737714e4d59863" name="ga343f3f618f0fe483a2737714e4d59863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343f3f618f0fe483a2737714e4d59863">&#9670;&#160;</a></span>can_add_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int nudge::can_add_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body_to_clone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>1 if <a class="el" href="group__add__group.html#ga996425d8924b4bababdc993e30e6dce0">add_clone(...)</a> can be called successfully </dd></dl>

</div>
</div>
<a id="ga4f53241ed3f4a4ee707c312731580076" name="ga4f53241ed3f4a4ee707c312731580076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f53241ed3f4a4ee707c312731580076">&#9670;&#160;</a></span>get_next_add_body_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned nudge::get_next_add_body_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to peek the body index that is going to be returned in next <a class="el" href="group__add__group.html">add_xxx(...)</a> call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of the following values: c-&gt;bodies.count, c-&gt;global_data.removed_bodies[0] or <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Next call to any <a class="el" href="group__add__group.html">add_xxx(...)</a> function can still return <a class="el" href="nudge_8h.html#ae74472be675104576b5f1c8bc17c9cc2">NUDGE_INVALID_BODY_ID</a>, if the number of available colliders runs out (that condition can be queried before adding the body using <a class="el" href="group__add__group.html#ga7a7eae5e6e78aca5e58d68f57c0b27b6">colliders_get_num_remaining_boxes(...)</a>, <a class="el" href="group__add__group.html#ga2cfc40db29c2e1e2f2d5e5e71ecfa5f9">colliders_get_num_remaining_spheres(...)</a> or <a class="el" href="group__add__group.html#ga13bd7e16bb70f5d62af617ea052c925f">can_add_box(...)</a>, <a class="el" href="group__add__group.html#gaeb5daf3798a9cd8895329eb3fae98c9f">can_add_sphere(...)</a>, <a class="el" href="group__add__group.html#ga2dd9f9353cbaa67f9ba9e809cd59047e">can_add_compound(...)</a>) </dd>
<dd>
The returned body is valid until next <a class="el" href="group__main__group.html#ga5e40e2507c7ad9e6e547c843042c75f1">simulation_step(...)</a> call </dd>
<dd>
A returned value of c-&gt;bodies.count can still be used, because the arrays are allocated at context init time, with a size of c-&gt;MAX_NUM_BODIES </dd></dl>

</div>
</div>
<a id="ga1f93cae567db28c0208a5494260b6cff" name="ga1f93cae567db28c0208a5494260b6cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f93cae567db28c0208a5494260b6cff">&#9670;&#160;</a></span>body_recalculate_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nudge::body_recalculate_bounding_box </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculates the bounding box of the body (<a class="el" href="structnudge_1_1BodyInfo.html">BodyInfo::aabb_center and BodyInfo::aabb_extents</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">body</td><td>the body index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is already called when bodies are added (see <a class="el" href="group__add__group.html">add_xxx</a> functions); so it's almost pointless to call it again (except maybe when manually changing the size of some collider) </dd>
<dd>
<a class="el" href="nudge_8h.html">nudge.h</a> does not use the body bounding box at all: it has been added just to ease user experience </dd></dl>

</div>
</div>
<a id="gac7780301e58b1427a98bf9528b364286" name="gac7780301e58b1427a98bf9528b364286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7780301e58b1427a98bf9528b364286">&#9670;&#160;</a></span>body_change_motion_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nudge::body_change_motion_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">nudge::context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenudge.html#a18b09ad52308ede8a1c65cc0ba442adf">nudge::FlagMask</a>&#160;</td>
          <td class="paramname"><em>new_motion_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass_fallback</em> = <code>1.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Experimental] Changes the body motion state (i.e. the BF_IS_STATIC_OR_KINEMATIC_OR_DYNAMIC group of body flags) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">body</td><td>the index of the body </td></tr>
    <tr><td class="paramname">new_motion_state</td><td>the desired new motion state; it must be: BF_IS_STATIC, BF_IS_KINEMATIC or BF_IS_DYNAMIC </td></tr>
    <tr><td class="paramname">mass_fallback</td><td>a mass fallback used only when 'new_motion_state' is BF_IS_DYNAMIC and the body had zero mass (the body was static) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Experimental feature: use it at your own risk and for a limited and selected amount of bodies </dd>
<dd>
This function resets the body velocities </dd>
<dd>
In case of BF_IS_DYNAMIC 'new_motion_state' this function can replace the components of inertia of the body, if it was not set before (the body was static) with a box inertia on the body axis aligned bounding box </dd>
<dd>
It's better to leave static bodies alone, and just make kinematic bodies dynamic or viceversa </dd></dl>

</div>
</div>
<a id="ga94f40bbfb338b401de8427b86287981f" name="ga94f40bbfb338b401de8427b86287981f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f40bbfb338b401de8427b86287981f">&#9670;&#160;</a></span>body_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nudge::body_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnudge_1_1context__t.html">nudge::context_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mass_scale_factor</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[Experimental] Uniformly scales the specified body incrementally </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the nudge context </td></tr>
    <tr><td class="paramname">body</td><td>the target body </td></tr>
    <tr><td class="paramname">scale_factor</td><td>positive =&gt; the uniform scaling factor to apply (to each single axis); negative =&gt; scale so that the half bounding box y-component of the body becomes exactly -scaling_factor; 0 =&gt; invalid value (asserts) </td></tr>
    <tr><td class="paramname">mass_scale_factor</td><td>positive =&gt; the scaling amount to apply to the mass; 0 =&gt; sets 'mass_scale_factor' to the cube of the 'scaling_factor' argument; negative =&gt; sets the new mass exactly to -mass_scale_factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Experimental feature: use it at your own risk and for a limited and selected amount of bodies </dd>
<dd>
Since the scaling is incremental, floating point errors are introduced when this function is called multiple times (e.g. calling it with 2.f and then with 0.5f is not perfectly equivalent to leaving the body unscaled), and it's not possible to retrieve the scaling factor that has been applied </dd>
<dd>
In case 'mass_scale_factor' is negative and the body has no inertia set, a box inertia for the body is calculated on the body axis aligned bounding box </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
